---
title: "Quick Start"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{semfindr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Purpose

The [semfindr] package has functions for doing SEM (
structural equation modeling) diagnostics, such as 
identifying influential cases and computing various
diagnostic measures.

# Workflow

Many of the measures for a case is computed by refitting
a model with this case removed. Instead of doing this once
for each measure, [semfindr] refits the model for at most
as many times as the number of cases, each time with one
case removed, store them as a list of SEM results.
Functions for deletion statistics will compute them from
this list. By saving this list of results, users can do
any further diagnostic analysis later without repeating this
time consuming process.

# Loading the Package and the Sample Dataset

First, we load the package. The sample dataset is [pa_dat2],
with variables `iv1`, `iv2`, `m1`, and `dv`, and 100 cases.
For conveienice, we assign [pa_dat] to a new symbol, `dat`.

```{r}
library(semfindr)
dat <- pa_dat
head(dat)
```

# Fitting the Target Model

Assume that the target model under examination is a path
model with two predictors, one mediator, and one outcome
variable:

```{r}
mod <-
"
m1 ~ iv1 + iv2
dv ~ m1
"
```

We fit the model by [lavaan::sem]:

```{r}
library(lavaan)
fit <- sem(mod, dat)
```

# Fit the Model *n0* Times

We refit the model 100 times, each time with one case
removed:

```{r}
fit_rerun <- lavaan_rerun(fit)
```

This example takes about 4 to 8 seconds. For larger samples
or more complicated models, [lavaan_rerun] supports
parallel processing by setting `parallel` to `TRUE`.

If this process is slow, we can seave `fit_rerun` by 
`saveRDS` such that we can load it for future analysis.

# Standardized Change in Parameter Estimates

One intuitive measures is to compute the change in parameter
estimates if a case is deleted, standardizing the changes
by their standard error.

```{r}
fit_est_change <- est_change(fit_rerun)
round(head(fit_est_change), 3)
```

`est_change` will compute the generalized Cook's distance,
`gcd` using the parameters examined. `gcd` is analogous to
Cook's distance in multiple regression, measure the
"overall" change in the parameters if a case is deleted.

Let's examine the top five cases with largest `gcd`:

```{r}
i <- order(fit_est_change[, "gcd"],
           decreasing = TRUE)
round(fit_est_change[i[1:5], ], 3)
```

We can also specify the parameters to be included. For
example, we may only want to compute the change and the
`gcd` only for path coefficients. See the help
page of `est_change` for the detail.

# Compute raw change in parameter estimates

```{r}
head(est_change_raw(fit_rerun))
head(est_change_raw(fit_rerun, standardized = TRUE))
```

Compute Mahalanobis distance

```{r}
head(mahalanobis_rerun(fit_rerun))
```

Compute fit measure changes. E.g., chisq, cfi, tli, and rmsea

```{r}
head(fit_measures_change(fit_rerun,
                         fit_measures = c("chisq", "cfi", "tli", "rmasea")))
```

Request all those statistics in one call.

```{r}
influence_out <- influence_stat(fit_rerun)
head(influence_out)
```

See ?influence_stat for options.

Plot generalized Cook's distance

```{r}
gcd_plot(influence_out)
```

Can set the number of cases to label, based on the distance.

```{r}
gcd_plot(influence_out,
         largest_gcd = 3)
```

See ?gcd_plot.

Plot Mahalanobis distance

```{r}
md_plot(influence_out,
        largest_md = 3)
```

See ?md_plot.

Plot a fit measure against generalized Cook's distance

```{r}
gcd_gof_plot(influence_out,
             fit_measure = "chisq")
```

See ?gcd_gof_plot.

Plot a fit measure against Mahalanobis distance, with bubble size determined 
by generalized Cook's distance.

```{r}
gcd_gof_md_plot(influence_out,
                fit_measure = "chisq")
```

Can use circle_size to control the size of the largest bubble.

```{r}
gcd_gof_md_plot(influence_out,
                fit_measure = "chisq",
                circle_size = 10)
```

Can add cutoff lines

```{r}
gcd_gof_md_plot(influence_out,
                fit_measure = "chisq",
                circle_size = 10,
                cutoff_fit_measure = 1,
                cutoff_md = 9)
```

Other influence plot functions also have these features.
See ?influence_plot for more options.

Compute implied scores

```{r}
fit_with_means <- sem(mod, dat, meanstructure = TRUE)


fit_implied_scores <- implied_scores(fit_with_means)

head(fit_implied_scores)
```